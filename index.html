<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>QuantMage → Excel Exporter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }
    .box { border: 1px dashed #aaa; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 12px; border-radius: 8px; border: 1px solid #999; background: #f5f5f5; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .muted { color: #666; font-size: 12px; }
    code { background: #f2f2f2; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>QuantMage → Excel Exporter</h1>
  <p class="muted">
    Choose a saved QuantMage HTML (either $ or % view). This creates a formatted <b>.xlsx</b> with
    a <b>Metrics</b> sheet (Gain, CAGR, MD, WinRate, Volatility, Cumulative Return in %)
    and a <b>Correlations</b> sheet. Columns empty for every row are omitted. Everything runs locally.
  </p>
  <div class="box">
    <div class="row">
      <label><b>Saved HTML:</b> <input type="file" id="htmlFile" accept=".html,.htm"></label>
      <button id="runBtn" disabled>Export → <code>QM_export.xlsx</code></button>
    </div>
    <div id="log" class="muted" style="margin-top:8px;"></div>
  </div>

<script>
/* ---------- helpers ---------- */
const RE_CONST = name => new RegExp(`const\\s+${name}\\s*=\\s*(".*?");`, 's');
function parseDoubleJSON(jsStringLiteral){ const inner = JSON.parse(jsStringLiteral); return JSON.parse(inner); }
function ymdToDate(i){ const s=String(i); return new Date(+s.slice(0,4), +s.slice(4,6)-1, +s.slice(6,8)); }
function inferDates(vals, datesList, lastValueDate){
  const n=vals.length;
  if(Array.isArray(datesList)&&datesList.length>=n){ return datesList.slice(-n).map(ymdToDate); }
  const end=(typeof lastValueDate==='number')? ymdToDate(lastValueDate) : new Date();
  const out=[]; for(let i=0;i<n;i++){ const d=new Date(end); d.setDate(d.getDate()-(n-1-i)); out.push(d);} return out;
}
function pctReturns(values){ const out=[]; for(let i=1;i<values.length;i++){ const a=values[i-1], b=values[i]; if(a>0) out.push(b/a-1);} return out; }
function stdev(arr){ if(arr.length<2) return 0; const m=arr.reduce((a,b)=>a+b,0)/arr.length; const v=arr.reduce((s,x)=>s+(x-m)*(x-m),0)/arr.length; return Math.sqrt(v); }
function maxDrawdown(values){ let peak=values[0], mdd=0; const dd=[]; for(const v of values){ peak=Math.max(peak,v); const d=v/peak-1; mdd=Math.min(mdd,d); dd.push(-d);} return {mdd, dd}; }
function ulcerIndex(dd){ if(!dd.length) return NaN; const ms=dd.reduce((s,x)=>s+x*x,0)/dd.length; return Math.sqrt(ms); }
function toDateISO(d){ const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`; }

/* correlation with overlap, return null for non-finite */
function corrForMaps(mapA, mapB){
  const keys = Object.keys(mapA).length < Object.keys(mapB).length ? Object.keys(mapA) : Object.keys(mapB);
  let xs=[], ys=[];
  for(const k of keys){ if(mapA[k]!==undefined && mapB[k]!==undefined){ xs.push(mapA[k]); ys.push(mapB[k]); } }
  if(xs.length < 2) return null;
  const mean = a => a.reduce((p,c)=>p+c,0)/a.length;
  const mx=mean(xs), my=mean(ys);
  let num=0, denx=0, deny=0;
  for(let i=0;i<xs.length;i++){ const dx=xs[i]-mx, dy=ys[i]-my; num+=dx*dy; denx+=dx*dx; deny+=dy*dy; }
  const den = Math.sqrt(denx*deny);
  if(den<=0) return null;
  let r = num/den;
  if(!isFinite(r)) return null;
  if(r>1) r=1; if(r<-1) r=-1;   // clamp tiny FP errors
  return r;
}

/* ---------- main ---------- */
async function run(){
  const file = document.getElementById('htmlFile').files[0];
  if(!file){ alert('Pick a saved HTML file first'); return; }
  const html = await file.text();

  const mTS = RE_CONST('trading_spells').exec(html);
  if(!mTS){ alert('Could not find "const trading_spells" in the HTML'); return; }
  const trading_spells = parseDoubleJSON(mTS[1]);

  const mDates = RE_CONST('dates').exec(html);
  const dates_list = mDates ? parseDoubleJSON(mDates[1]) : null;

  const base = "https://quantmage.app/grimoire/";
  const rowsRaw = [];
  const names = [];
  const returnsMaps = {}; // name -> {dateISO: dailyReturn}

  for (const [sid, payload] of Object.entries(trading_spells)){
    const td = payload.trading_data || {};
    const vals = Array.isArray(td.
